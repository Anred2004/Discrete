import math
from random import randint


# Функция для получения вершины с наибольшей пропускной способностью
def get_max_vertex(k, V, S):
    m = 0  # наименьшее допустимое значение
    v = -1
    for i, w in enumerate(V[k]):
        if i in S:
            continue

        if w[2] == 1:  # движение по стрелке
            if m < w[0]:
                m = w[0]
                v = i
        else:  # движение против стрелки
            if m < w[1]:
                m = w[1]
                v = i

    return v


# Функция для получения максимального потока
def get_max_flow(T):
    w = [x[0] for x in T]
    return min(*w)


# Функция для обновления весов в таблице
def updateV(V, T, f):
    for t in T:
        if t[1] == -1:  # это исток
            continue

        sgn = V[t[2]][t[1]][2]  # направление движения

        # меняем веса в таблице для (i,j) и (j,i)
        V[t[1]][t[2]][0] -= f * sgn
        V[t[1]][t[2]][1] += f * sgn

        V[t[2]][t[1]][0] -= f * sgn
        V[t[2]][t[1]][1] += f * sgn


# Основная функция для алгоритма Форда-Фалкерсона
def fordFulkerson(V, mapper):
    N = len(V)  # число вершин в графе
    init = 0  # вершина истока (нумерация с нуля)
    end = N - 1  # вершина стока
    Tinit = (math.inf, -1, init)  # первая метка маршрута (a, from, vertex)
    f = []  # максимальные потоки найденных маршрутов
    pathes = []
    j = init
    last_S = []
    while j != -1:
        k = init  # стартовая вершина (нумерация с нуля)
        T = [Tinit]  # метки маршрута
        S = {init}  # множество просмотренных вершин

        while k != end:  # пока не дошли до стока
            j = get_max_vertex(k, V, S)  # выбираем вершину с наибольшей пропускной способностью
            if j == -1:  # если следующих вершин нет
                if k == init:  # и мы на истоке, то
                    break  # завершаем поиск маршрутов
                else:  # иначе, переходим к предыдущей вершине
                    k = T.pop()[2]
                    continue

            c = V[k][j][0] if V[k][j][2] == 1 else V[k][j][1]  # определяем текущий поток
            T.append((c, j, k))  # добавляем метку маршрута
            S.add(j)  # запоминаем вершину как просмотренную

            if j == end:  # если дошли до стока
                f.append(get_max_flow(T))  # находим максимальную пропускную способность маршрута
                updateV(V, T, f[-1])  # обновляем веса дуг
                break

            k = j
        last_S = S
        pathes.append(T)
    pathes.pop()
    F = sum(f)
    print(f"Максимальный поток равен: {F}")
    print('Минимальный разрез:')
    print('A:', end=' ')
    for i in range(N):
        if i in last_S:
            print(mapper[i], end=' ')
    print()
    print('B:', end=' ')
    for i in range(N):
        if i not in last_S:
            print(mapper[i], end=' ')
    print()


# Основная функция программы
def main():
    mapper = {0: 'S', 1: 'p', 2: 'a', 3: 'd', 4: 'k', 5: 'c', 6: 'b', 7: 'T'}
    print('Заданный граф:')
    V = [
        [[0, 0, 1], [7, 0, 1], [3, 0, 1], [5, 0, 1], [0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 0, 1]],
        [[7, 0, -1], [0, 0, 1], [0, 0, 1], [0, 0, 1], [2, 0, 1], [0, 0, 1], [3, 0, 1], [0, 0, 1]],
        [[3, 0, -1], [0, 0, 1], [0, 0, 1], [2, 0, 1], [1, 0, 1], [0, 0, 1], [6, 0, 1], [0, 0, 1]],
        [[5, 0, -1], [0, 0, 1], [2, 0, -1], [0, 0, 1], [2, 0, 1], [6, 0, 1], [0, 0, 1], [0, 0, 1]],
        [[0, 0, 1], [2, 0, -1], [1, 0, -1], [2, 0, -1], [0, 0, 1], [0, 0, 1], [0, 0, 1], [6, 0, 1]],
        [[0, 0, 1], [0, 0, 1], [0, 0, 1], [6, 0, -1], [0, 0, 1], [0, 0, 1], [1, 0, 1], [4, 0, 1]],
        [[0, 0, 1], [3, 0, -1], [6, 0, -1], [0, 0, 1], [0, 0, 1], [1, 0, -1], [0, 0, 1], [5, 0, 1]],
        [[0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 0, 1], [6, 0, -1], [4, 0, -1], [5, 0, -1], [0, 0, 1]],

    ]
    fordFulkerson(V, mapper)

    # Генерация случайных весов ребер
    for i in range(len(V)):
        for j in range(i + 1, len(V)):
            if V[i][j][0] != 0:
                val = randint(100, 1001)
                V[i][j][0] = val
                V[j][i][0] = val
    print('Граф со случайными весами ребер:')
    fordFulkerson(V, mapper)


main()
